# Python学习笔记

# 概述

**加粗**：用以重点强调；

*斜体*

> 块引用：block quoting

横线：三个短横线

---

[link](http://www.baidu.com)

[内部link](#OOP：宏伟蓝图)

```
代码块
```

`print()`

利用机器代替人，是效率提升的一个重要手段，在测试工作中，产品测试用例的自动化执行是这个思路的非常重要的体现，我们希望测试人员能够非常好的掌握这个手段，这就是这个系列的目标：

- 对IPC自动化所需要的知识进行梳理，给大家一个清晰的路线图；
- 对关键知识点进行介绍讲解，能掌握并在工作实践中应用；

并且按照刻意练习的原则更偏重获得技能，而非仅仅获取知识（强实践、练习），并且强调在情景中学习，从工程的角度去学习。

用机器代替人，实际上的意思是让机器去为我们做一些事情，以当前的发展来看，机器擅长的往往是人不擅长的，正好可以形成互补。比如阅读一篇文章，人擅长的是理解其中的意思，但是如果要给出这篇文章中各个单词出现的频率就不是人擅长的了，而这恰恰是机器擅长的。

人有人言，兽有兽语，计算机也有自己的语言，并且我们这个伙伴性格直爽，你希望它做什么一定要告诉的清晰明确，要不它就会不知所措，可以说既聪明又笨拙，属于典型的推一下，动一下，从这个意义上来讲，程序就是一些列指令的集合，我们提前把需要计算机做的事情写下来，计算机拿到之后只需要对照这个清单一步步做下去就行了。对于一门语言来说，两方面的技能是必须的：

- 单词与语法，进而写出句子；
- 讲故事的能力：我们是通过“故事”来传递我们的观点/想法，对于计算机来说，观点就是要解决的问题。

掌握单词与语法，写出句子来，这个是基础，可以非常迅速的掌握，对于Python来说就是基础数据结构、条件语句、循环语句、模块等基础知识，以及迭代器、生成器、装饰器等进阶知识；讲故事的能力相对复杂，但是学习编程与学习写作非常类似，我们可以通过阅读理解背诵“范文”的方式来学习锻炼讲故事的能力，在编程中“文章”是指一些好的实践（项目源码）

**每个研究领域都有自己的语言和思考方式**。数学家谈论公理、积分和向量空间；心理学家谈论自我、本我和认知失调；律师谈论案发现场、侵权行为和允诺禁止反言原则。经济学家也没有什么不同。供给、需求、比较优势、消费者剩余、无谓损失等等这些术语都是经济学家语言的一部分。**乍一看，这种语言似乎有一种不必要的神秘，但是它的价值在于能够为你提供一种关于你所生活的世界的新的、有用的思考方式。**

编程语言也有自己的一些术语、概念，下面是常见的一些

## 何谓程序

程序是由一些列为了做某事而组织在一起的语句，程序可以只有一条语句，也可以有很多条。如果从更高层面来理解：我们为现实世界要解决的问题进行建模（创建数据结构），然后编写代码对这个数据结构进行解释，这些就构成了程序。



虽说有了语言，我们应该可以与计算机进行交互了，但是计算机的核心CPU只能理解机器语言：

> 000101000010101010101000100101001010101001010101010101000000111010100

机器语言与CPU硬件紧密相连（比如不同指令集的CPU），并且人理解使用起来很困难，所以需要一个媒介或者说软件能把它们变得易懂一些，把易于人理解使用的语言（所谓的高级语言）转换成计算机的机器语言，这个中间媒介就是编译器或者解释器，他们充当这个翻译转换的动作

**解释器（interpreter）**：在阅读程序代码的时候，一边解析一边执行；

**编译器（compiler）**：把整个代码文件作为一个整体，进行处理，转换为机器语言文件，后直接运行这个机器语言文件。

前面提到，程序是由单词、语句、语句结构、段落结构、故事结构等构成，在程序构建过程中，还有一些基础概念需要了解：

- 输入：从外部世界获取数据，常见的有从文件中读取，从输入设备中（鼠标、键盘、各类传感器等）获得等；
- 输出：用于展示程序运行结果，常见的方式有：显示器、存到一个文件中、音频输出等；
- 顺序执行：按照语句在代码中出现的先后顺序依次执行；
- 条件执行：通过检查条件，来控制执行或者跳过语句；
- 循环执行：重复执行某语句；
- 重用：一组指令/语句写好之后，通过给他们一个名字，从而在整个程序中都可以通过这个名字来直接使用这组语句。

**对于python来说，程序是由语句构成的，而语句即可能由关键字定义，也可能由表达式构成，表达式则由操作符与操作数构成**

**操作符**：包括算术操作符、比较操作符、逻辑操作符；

**操作数**：任何的变量都可以是操作数，并不一定是数字。比如列表也支持相加，或者乘以一个整数等操作；

**注释**：注释让你能够使用自然语言在程序中添加说明；**编写注释的主要目的是阐述代码要做什么，以及是如何做的**。通俗讲就是“使用人类语言来解释计算机语言”。在开发项目期间，你对各个部分如何协同工作了如指掌，但过段时间后，有些细节你可能不记得了，当然你总是可以通过研究代码来确定各个部分的工作原理，但通过写注释，以清晰的自然语言对解决方案进行概述，可节省很多时间。做为新手，最值得养成的习惯之一是在代码中编写清晰、简洁的注释。

## 错误与调试

**语法错误**：程序中包含非法的python代码时就会导致语法错误；

**逻辑错误：**从语法上代码是合法的，但是结果并不符合预期。

编写程序时，编辑器会以各种方式突出程序的不同部分，例如它知道`print`是一个函数，因此将其显示为蓝色等等，这个功能被称为**语法突出**；在编写脚本的时候，比如你输入`print("hello world")`实际上python并不关心你里面的内容是什么，它只是看到print那么就按照print的规定把动作做了。



# 语义语法

### 表达式

是语言最基础的结构，由操作数与操作符组成，并且总是可以求值（也称为规约）为单个值，这意味着在python中所有使用表达式的地方都可以使用单个值，反之亦然；2+2 就是一个表达式。将操作符与和值放在一起构成表达式的这些规则，是python编程语言的基本部分，就像帮助我们沟通的语法规则一样：

> This is a grammatically corrected English sentence
>
> This grammatically is sentence not English correct a.

上面例子第二行很难解释，因为它不符合英语语法规则。类似的，如果你输入python不能理解的指令，它就会报错。类似Syntax Error。。。

常见的操作符主要有：数学运算操作符（加减乘除等）、逻辑运算操作符（与或非等）、比较操作符等（大于小于等于等）；

### 语句

python中的语句就跟其关键字类似，是有明确数量的，常见的有：

- 赋值语句；

- 调用

- if/elif/else选择语句

  以流程图为例子，介绍控制流语句。控制流语句决定在什么条件下执行哪些python语句。

- 循环语句（for，while等）

- 函数与方法定义（def语句）

- break/continue语句

- 模块导入（from...import)

- 构建对象（class）

- 异常相关（raise，try。。。except）

程序由模块构成，模块包含语句，语句包含表达式，表达式包含操作符与操作数。如果程序是使用材料来处理事物，那么语句就是处理事物的方式。

### 变量

每个变量都存储了一个值---与变量相关联的信息。在python中使用变量的时候，需要遵守一些**规则**和**指南**。违反这些规则将导致错误，而指南旨在让编写的代码更容易理解:

- 变量名只能包含字母、数字和下划线，但不能以数字开头；
- 不要讲python关键字和函数名用作变量名；
- 变量名应该即简短又具有描述性：name比n好，name_length比length_of_person_name好。
- 慎用小写字母l和大小写字母O，它们可能被错看成数字1和0；
- 应该使用小写的变量名

如果把实际的数据类比为一个盒子，那么变量就是贴在这个盒子上的标签。

---

python中变量不需要事先声明，变量在定义的时候同时会被创建，变量的定义称为绑定（把名称与实际对象绑定在一起），常用的绑定方法有：

- 赋值语句；
- import语句
- def 语句（创建函数/方法或者类）
- 函数实参传递
- for循环头
- 与with或者except语句一起使用的as语句

变量有一个作用域的概念，表明了变量的生效范围，变量的作用域就是变量定义时所在的代码块



# 常见数据类型

## 对象

在python中对象（object）是对数据的抽象，数据在python程序中都可以用对象或者对象之间的关系来表示。一个对象由3部分组成：

- id：对象的id，可以理解为就是对象在内存中所在存储区域的地址，一旦被创建，id就不会再改变；
- type：对象的类型，也就是所谓的数据类型，决定了对象的行为（如支持的操作等）
- value：对象的值

大多数程序都定义并收集某种数据，然后使用它们来做有意义的事情。就像我们不能把所有物品都称为“东西”一样，在程序中对数据进行分类大有裨益。python常见的数据类型有：

![image-20200908065252063](/Users/wangguangli/Library/Application Support/typora-user-images/image-20200908065252063.png)

常见的对象创建方式如下：

- **通过特定符号直接创建对象：**比如通过引号定义字符串，通过中括号【】创建列表，通过花括号{}创建字典等；
- **通过表达式**：包括\+ \- * / 数学运算符、> < == !=等比较运算符、and or not 等逻辑运算符、in not in 存在性判定等；
- **通过函数或者方法的调用**：函数和方法都是典型的可调用数据类型，**方法是python可对数据执行的操作**，使用"."操作符，表示作用到数据上。比如name.title()中，name后面的句点让Python对变量name执行方法title指定的操作。每个方法后面都跟着一对括号，这是因为方法通常需要额外的信息来完成其工作。

## 字符串str

*字符串*就是一系列字符。在python中，用**引号**（单、双、三引号）括起来的都是字符串

```python
'This is a string'
"This is also a string"
'''This is also also a string'''
```

使用字符串的一个小技巧：

```python
message = "This car an go approximately" + str(range)
message += "miles on a full charge"
```

使用上面的技巧可以有效避免每行过长的问题。

- 转义字符：反斜杠“\\"，用以输入一些本身具有特殊含义的字符，让其原本的特殊含义不再生效；
- 原始字符串：在字符串开始的引号之前加上r，原始字符串会忽略字符串中的转义字符
- 格式化字符串
- 常用的字符串方法（是字符串的方法）：
  - 判断字符串是否以指定字符开始或者结束：startswith(), endswith()
  - 把一个列表项目使用指定的字符拼接成一个字符串，或者把一个字符串使用指定的风格符分成一个列表：join(), split()
  - 从字符串两端删除特定字符：strip(), rstrip(), lstrip()



空字符并不等于空白字符

```python
print('you' + 'and' + 'me')
print('you' + '' + 'and' + '' + 'me')
print('you' + ' ' + 'and' + ' ' + 'me')
输出：
youandme
youandme
you and me
```

##  列表list

列表是由一系列按照特定顺序排列的元素组成，你可以将任何东西加入到列表中，其中的元素之间可以没有任何关系。列表是可变、有序的，列表的有序是只数据存储的有序，并非指数据本身内容的有序，列表中的数据之间在编程语言语法的层面上是没有任何关系的。

- 可以通过索引方式访问列表的一个或者多个数据：[ ]，索引是从0开始，负号“-”索引表示从后向前；
- 支持in和not in 操作符；
- 可以使用方法：append(),insert()向列表中增加数据；
- 可以使用del语句、pop方法或者remove方法从列表中删除数据；
- 组织列表：可以使用sort方法对列表进行永久排序，使用sorted函数得到列表排序的副本；可以使用reverse方法对列表反转；

术语“列表值”指的是列表本身（它作为一个值，可以保存在变量中，或传递给函数，像所有其他值一样），而不是指列表之内的那些值。

列表是可变的。变量不直接保存列表值，它们保存对列表的引用，在复制变量或将列表作为函数调用的参数时，这点很重要：因为复制的只是对列表的引用，所以对该列表的所有改动都可能影响到程序中的其他变量。如果需要对一个变量中的列表修改，同时不修改原来的列表，可以使用copy模块的copy() 函数或者deepcopy()函数

## 字典dict

字典是一系列键值对，每个健都与一个值相关联，是python中唯一的映射类型。字典是一种动态的结构，可以随时在其中添加键值对，不过python不关心键值对的添加顺序，而只关心健和值之间的关联关系（可变，无序）。键值对之间以逗号分隔。

```python
favorite_languages = {
  'jen': 'python',
  'sarah': 'c',
  'edward': 'ruby',
  'phil': 'python',
}

print("sarah's favorite language is " +
     favorite_languages['sarah'].title() +
      "."
     )
```

上看的例子除了演示了如何定义字典（特别是多行的情况下，在最后一个键值对后仍推荐增加一个逗号分隔符），以及如何将较长的print语句分成多行。

字典的常用方法：

- items（），keys（），values（）；
- setdefault（），get（）
  - setdefault：有两个参数，第一个是要检查的健，第二个是如果该健不存在时要设置的值；在需要为字典中某个健设置一个默认值的时候使用；该方法是一个非常好的快捷方式，可以确保一个健的存在；
  - get：两个参数，第一个是要取得其值的健，第二个是如果该健不存在时返回的备用值。在获取字典某个健值时非常常用（这样，不用担心这个健是否存在与字典中）



## 函数

函数是带名字的代码块，使用def语句定义。函数是实现DRY（Don‘t Repeat Youself）的重要手段。与函数相关的一些概念：

- 形参与实参；
- 位置参数与默认参数；
- 传递任意数量的参数：形参类似*toppings中的星号让python创建一个名为toppings的空元组，并将收到的所有值都装到这个元组中，即使只传递了一个实参，也会被封装到元组中；
- 形参类似**user_info会让python创建一个名为user_info的空字典，并将收到的所有名称-值都封装到这个字典中，这样在函数体中就可以像访问其他字典一样访问user_info

每个函数都应该只负责一项具体的工作，不要让函数做太多内容，如果需要那么建议分成多个函数。

编写函数的时候，需要牢记几个细节：

1. 应给函数指定描述性名称，且只在其中使用小写字母和下划线；
2. 每个函数都应该包含简要地描述其功能的注释，该注释应该紧跟在函数定义后面，并采用文档字符串格式；
3. 给形参指定默认值的时候等号两边不要留空格，对于函数调用中的关键字参数，也应该遵循这种约定；
4. 多个函数之间使用两个空行将相邻的函数分开

通常对于一个函数，你要知道的就是它的输入值和输出值，你并非总是需要加重自己的负担，弄清楚函数的代码实际是怎样工作的，如果以这种高层的方式来思考函数，通常大家会说，你将该函数看作成一个黑盒。这个思想是现代编程的基础。

## 类

在Python中使用**class 语句**可以实现一种新的对象**类**，它是python面向对象程序设计的主要工具。OOP是一种编程范式，使用类需要一些预先的规划，因此相比于采用战术模式工作的人（时间有限），采用战略模式工作的人（做长期产品开发）对类会更感兴趣一些。面向对象编程是最有效的软件编写方法之一。在面向对象编程中，你编写表示现实世界中的事物和情景的类，并基于这些类来创建对象。编写类时，你定义一大类对象都有的通用行为，基于类创建对象时，每个对象都自动具备这种通用行为，然后可根据需要赋予每个对象独特的个性。

从更具体的编程角度来看，类是Python程序的组成单元，就像函数与模块一样：**是封装数据和逻辑的另外一种方式**。与模块有点像，类也定义了新的命名空间，但是它有3个独特之处：

- 多重实例：类本质上是产生对象的工厂（我觉得模板更合适）；
- 继承：我们可以在类的外部编写子类，来重新定义父类的属性从而进行扩展；
- 运算符重载：通过定义特定的协议方法，类可以定义对象来响应在内置类型上的一些运算。

**从本质上来讲，Python的OOP机制主要依托于两个基础：**

- **一个特殊的函数第一位参数（来接收调用主体）；**
- **继承属性搜索**

OOP不仅仅是一门技术，更是一种经验。Python中大多数OOP的故事，都可简化成如下表达式：

*object.attribute*

当我们对class语句产生的对象使用这种方式时，这个表达式会在Python中启动一次搜索：搜索对象链接的类树，来寻找attribute首次出现的类，用自然语言描述如下：

> 找出attribute首次出现的地方，先搜索object，然后是该对象之上的所有类，由下往上，由左到右。

换句话说**属性访问就是搜索类树而已**。我们称这种搜索为**继承**，因为树中较低位置的对象继承了树中位置较高的对象所拥有的属性。继承就是“**爬树**”。

![image-20200616072544715](/Users/wangguangli/Library/Application Support/typora-user-images/image-20200616072544715.png)



上图展示了一棵包含了5个对象的类树：3个类对象（C1、C2、C3）和两个实例对象（I1、I2）。

假设我们创建了上图的类树之后，然后编写：

```python
I2.w
```

因为这是一个 *object.attribute* 表达式，所以这个代码会立即启用**继承**，它会触发上图中的搜索，确切的讲就是按照下面这个顺序搜索连接的对象：

​        I2，C1，C2，C3

**找到首个w之后就会停止搜索**（如果找不到就会报错）。此例中，直到搜索到C3时才会找到w，也就是说，通过自动搜索，I2.w会解析为C3.w。用OOP的术语来说，I2从C3继承了属性w。

如果I2.w引用时一个函数调用，其实际的含义将会是“调用C3.w函数来处理I2”，也就是说Python将会自动将I2.w( )调用映射为C3.w(I2)（同时传入该实例作为继承的函数的第一位参数）。每当我们以这种方式调用附属于类的函数时，总会隐含着这个类的实例，这个隐含的主体或者上下文就是将其称之为面向对象模型的一部分原因：**当操作执行时，总是有个主体对象（调用的主体）**。Python把隐含的实例传入方法中特殊的第一位参数，习惯上称其为self，方法通过这个参数来处理调用的主体。例如对于Employ类的实例bob，在运行bob.giveRaise（）方法调用时会做两件事：

1. 在bobo中通过继承搜索寻找giveRaise（）方法；
2. 将bob传入找到的giveRaise方法，并赋值给self参数。

**类树的创建**：

- 每个class语句会生成一个新的类对象；
- 每次类调用时，就会生成一个新的实例对象；
- 实例自动链接到创建它们的类；
- 类链接到其父类的方式是，将父类列在class头部的括号内；括号中从左到右的顺序会决定树中的次序。

super（）是一个特殊的函数，帮助python将父类与子类关联起来，我们可以在子类的方法中调用super（），从而访问父类，类似如下：

```python
super().__init__(make, model, year)
```



**运算符重载：**

构造函数\_\_init\_\_是运算符重载方法这一大类方法中最常用的代表。运算符重载方法的名称开头和结尾都带有双下划线，从而看起来十分特别。当能够支持这些操作的实例出现在对应的运算符旁时，Python会自动调用运行它们。运算符重载方法是可选的：如果缺省则不支持对应的运算。例如如果没有\_\_init\_\_方法，类调用将返回一个空实例，而不会将其初始化；例如要实现集合交集，类要么提供类似名为intersect的方法，要们编写名为\_\_add\_\_的方法来将“&”表达式运算符分发到处理交集所需要的逻辑。

虽然OOP会有更多细节，**不过大体而言，OOP就是在树中搜索属性和在函数中加入一个特殊的第一位参数**。



**类编码风格**

1. 类名应该使用驼峰命名法，实例名和模块名都采用小写格式，并在单词之间加上下划线；
2. 对于每个类，都应紧跟在类定义后面包含一个文档字符串，简要描述类的功能；
3. 类中可以用一个空行来分隔方法，在模块中可以用两个空行来分隔类；
4. 先编写导入标准库模块的import语句，再添加空行，然后编写导入第三方或者自己编写的模块的import语句

## 文件

变量是保存数据的好方法，但当希望程序结束后数据仍然保持，就需要将数据保存到文件中。文件有两个关键属性：

- 文件名：如xxx.doc
- 路径：如‘c:\windows\system\\'，在路径中有一个“路径分隔符”的符号，在windos下是反斜杠，mac及linux下是斜杠；

因此在python中一个完整的文件长得是这样子的：c:\windows\system\\xxx.doc'

有两种方法指定一个文件路径：

- 绝对路径，总是从根文件夹开始；
- 相对路径，它相对于程序的当前工作目录：
  - 单个句点是这个目录的缩写
  - 两个句点是父文件夹

python中的文件相关操作主要是借助os模块（或者其子模块）实现，一些常见的方法有；

- os.getcwd(), os.makedirs(), os.chdir()
- os.path.join()
- 获得文件的文件名：os.path.basename()
- 获得文件的路径：os.path.dirname()



# 进阶

## 工厂函数/闭包函数

工厂函数，又名闭包函数、闭合函数，与普通函数相比，有如下特点：

- 它的函数体中一般会再包含函数（子函数）（1～2个），这个子函数一般来说会被做为函数值返回；
- 它有一个元组类型的\_\_closure\_\_属性，这个属性里面存储自由变量的参数对象地址，这是工厂函数机制实现的底层根本：能记住嵌套作用域里的变量的值（嵌套作用域即是LEGB中的E）。

实例：

```python
def wrapperfun(strname):
  def recorder(age):
    print('姓名： ', strname, '年龄： ', age)
  return recorder

fun1 = wrapperfun('Anna')  #自由变量为Anna
fun1(37)                   #输出为：姓名：Anna 年龄：37

fun2 = wrapperfun('Gary')
fun2(32)
```

上面的例子中wrapperfun（）既是工厂函数，它有一个参数strname，这个变量的值在函数返回后仍然被保存了下来，我们看到在调用fun1(或者fun2)的时候，这个字符串被正确输出出来了。

需要注意的是wrapperfun不是工厂函数，是wrapperfun（）是工厂函数，它被调用后返回的值的类型仍然是个函数，是它是闭包函数。

```python
print(fun1.__closure__)    #输出类似 <cell at 0x000000B49E4c8:str object at 0x00000c4974b>
```

通过上面的输出可以看到，是一个cell，里面包含str object

> 在计算机编程中，术语"自由变量"是指在函数中使用的变量，它们不是局部变量，也不是函数的参数。 [1 ](http://en.wikipedia.org/wiki/Free_variable/)术语非本地变量通常是此
> 上下文中的同义词

## 装饰器（decorator）

装饰器本质上是闭包函数，比较特别的是该闭包函数的自由变量也是一个函数。装饰器可以大大增强代码的重用性与扩展性，比如对于某一个已经写好的函数，如果我们想再进行扩展，最直接的方法当然是直接对这个函数进行修改，但这样就违反了软件工程中的开发封闭的原则：**在一个项目的多个版本迭代之间，对于已经实现的功能代码不允许修改，但可以被扩展**。装饰器就是python中专门为软件工程服务的编程方法：它可以在原有的函数之外再包一层。具体就是新创建一个函数，把原有的函数做为自由变量，在新创建的函数体内做扩展工作，并进行原有函数的调用工作（这样原函数的功能也被保存了下来）。

装饰器的编写有很多中方式，最简单、易读的方式是：**编写一个返回子函数的函数，这个子函数包裹原函数**（To write a function that returns a sub-function that wraps the original function call)



## 正则表达式

正则表达式简称为regex，是文本模式的描述方法，它为文本模式匹配、抽取、搜索和替换等功能提供了基础。简单的说正则表达式就是由一些字符与特殊符号组成的字符串。例如，\\d是一个正则表达式，表示一位数字字符。python中所有正则表达式的函数都在re模块中，如果要使用需要先导入这个模块。使用正在表达式的步骤：

1. 导入模块re；
2. **创建Regex对象**：通过把正则表达式字符串传递给re.compile（）进行预编译从而创建Regex对象；
3. **调用Regex对象方法进行匹配**：向Regex对象的search（）方法传入要查找的字符串，如果没找到匹配的就返回None，如果找到了就会返回一个Match对象，Match对象有一个group（）方法，它返回被查找字符串中实际匹配的文本。

---

实际上预编译不是必须的，regex对象的所有方法，在re模块中都有单独定义的函数可以使用，但是推荐进行预编译

---

所以创建regex对象又是其中的关键。正则表达式的强大之处在于引入特殊字符来定义字符集、匹配子组和重复模式：

**字符定义（元字符）**：

- \d 0到9的任何数字

- \\D 除0到9的数字之外的任何字符

- \\w 任何字母、数字或下划线

- \\W 除字母、数字、下划线意外的其他字符

- \\s 空白字符（包括空格字符、制表符或换行符）

- \\S 空白字符之外的其他字符，非空白字符；
- 使用方括号[ ]定义自己的字符分类，如[aeiouAEIOU]将匹配所有元音字母；

**结构定义**

- 使用小括号（）进行分组；
- 使用管道符号｜来分隔多个模式；
- \*  星号之前的分组可以匹配0次或者多次；
- ？ 匹配0次或者1次前面的分组；
- \+  匹配1次或者多次前面的分组；
- { } 通过花括号，可以定义分组重复次数
- . 通配符，可以匹配除换行符之外的所有其他字符
- ^  插入字符如果出现在正则表达式开头，则表示匹配必须发生在被查找文本开始处，如果出现在方括号[ ]内，则表示不匹配方括号内的任意字符；
- $  美元字符如果出现在正则表达式末尾，则表示被查找的字符串必须以这个正则表达式所表示的模式结束

---

**特别说明**：

1. 如果想要匹配上面的特殊字符，那么就需要使用转义字符\\ ；一个例外是[ ]中，原因是在方括号中普通的正则表达式符号不会被解析，因此也就意味着在其中不需要使用转义字符；

2. ？如果与上面的频率定义符号一起使用，那么表示的是非贪婪模式（默认是贪婪模式）：档模式匹配使用分组操作符时，正则表达式引擎将试图“吸收”匹配该模式的尽可能多的字符，者通常叫做贪婪匹配；而问号要求正则表达式引擎去偷懒，如果可能，就在当前的正则表达式中尽可能少地匹配字符，留下尽可能多的字符给后面的模式（如果存在）。

   ```python
   import re
   
   target_str = '<To serverve man> for dinner.>'
   
   greedyregex = re.compile(r'<.*>')
   greedymo = greedyregex.search(target_str)
   greedy_result = greedymo.group()
   
   nongreedymo = re.compile(r'<.*?>')
   nongreedymo = nongreedymo.search(target_str)
   nongreedy_result = nongreedymo.group()
   
   print('贪婪匹配（默认）匹配结果：%s'%greedy_result)
   print('非贪婪匹配匹配结果     ：%s'%nongreedy_result)
   ```

   ```python
   贪婪匹配（默认）匹配结果：<To serverve man> for dinner.>
   非贪婪匹配匹配结果     ：<To serverve man>
   ```

---

使用re.compile()来创建正则表达式时，除了向其传递模式字符串外，还可以向其传递另外的参数，用以对模式定义内容进行修正：

- re.IGNORECASE：忽略大小写；

- re.DOTALL：让句点也能匹配换行字符；

- re.VERBOSE：通过这个参数，可以忽略模式字符串中的空白和注释，这样在正则表达式比较复杂时可以写的比较易读

  ```
  phone_regex = re.compile(r'''(
  (\d{3}|\(\d{3}))?            #区号
  (\s|-|\.)?                   #分隔符
  )'''
  )
  ```

  **使用sub（）方法替换字符串**

  正则表达式不仅能找到文本模式，而且能够使用新的文本替换掉这些模式。regex对象的sub方法需要传入两个参数：

  - 第一个是一个字符串，用于取代发现的匹配；
  - 第二个也是一个字符串，是待匹配的内容

  sub（）方法返回替换完成后的字符串。

  ```python
  nameregex = re.compile(r'Agent \w+')
  nameregex.sub(r'xxx', 'Agent Alice gave the secret documents to Agent Bob')
  替换后：
  xxx gave the secret documents to xxx
  ```

  有时候，可能需要使用匹配的文本本身，作为替换的一部分，在sub（）的第一个参数中，可以使用\\1, \\2, \\3 ...表示“在替换中输入分组1、2、3。。。的文本”

  ```python
  nameregex = re.compile(r'Agent (\w)\w*')
  nameregex.sub(r'\1xxx', 'Agent Alice gave the secret documents to Agent Bob')
  替换后：
  Axxx gave the secret documents to Bxxx
  ```

  



# 附录

## A-运行程序

所有python程序的第一行应该是#！行，它告诉计算机你想让python来执行这个程序。该行以#！开始，但是剩下的内容取决于操作系统：

- 在windows上，第一行是#！python3
- 在OS X上，第一行是#! /usr/bin/python3

没有#！行，你只能使用IDE或者python来运行脚本，但是如果想要从命令后直接运行脚本就必须要有这一行。

### 在windows上运行python程序

py.exe程序将读取.py文件源码顶部的#！行。为了方便运行你的python程序，可以创建一个BAT批处理文件，用py.exe来运行你的python脚本，批处理文件内容类似如下：

```
@py.exe c:\path\to\your\pythonscripy.py %*
@pause
```

注意使用你自己脚本的绝对路径来代替上面的路径，并把上面的内容保存为pythonscript.bat，建议把所有批处理文件和对应的.py文件都放在一个文件夹中，然后把这个文件夹路径添加到windows系统的path环境变量中，这样你就可以直接在cmd下运行该批处理文件了。

### 在OS X上运行python程序

OS X中可以通过终端窗口来运行脚本，终端窗口启动后将从你的用户账户的主文件夹开始（波浪符～是主文件夹的快捷方式，可以在任何路径下输入cd ～切换到主文件夹),如果用户名是wangguangli，那么主文件夹就是“/Users/wangguangli”

为了方便运行python程序，可以将你的脚本文件保存到你主文件夹，然后更改增加可执行权限，如chmod +x pythonscripyt.py,这样后续打开终端后，直接输入./pythonscripyt.py就能运行这个脚本，而脚本顶部的#！会告诉操作系统，在哪里可以找到python解释器。